import {
	TRANSFORM_FEEDBACK,
	TRANSFORM_FEEDBACK_BINDING
} from "../constants/constants.js";
import BadValueError from "../utility/BadValueError.js";
import type Context from "./Context.js";
import ContextDependent from "./internal/ContextDependent.js";
import Primitive from "../constants/Primitive.js";
import type Program from "./Program.js";
import type { VaryingMap } from "../types/VaryingMap.js";
import type VaryingValue from "../types/VaryingValue.js";
import type VertexBuffer from "./buffers/VertexBuffer.js";

/**
 * A transform feedback; used to capture primitives generated by the vertex processing step and record data from those primitives (varyings) into buffer objects.
 * @public
 */
export default class TransformFeedback extends ContextDependent {
	/**
	 * The currently-bound transform feedback cache.
	 * @internal
	 */
	private static bindingsCache = new Map<
		WebGL2RenderingContext,
		WebGLTransformFeedback | null
	>();

	/**
	 * Get the currently-bound transform feedback.
	 * @param context - The rendering context.
	 * @internal
	 */
	public static getBound(context: Context): WebGLTransformFeedback | null {
		// Get the bound transform feedback.
		let boundTf = TransformFeedback.bindingsCache.get(context.gl);
		if (typeof boundTf === "undefined") {
			boundTf = context.doPrefillCache
				? null
				: (context.gl.getParameter(
						TRANSFORM_FEEDBACK_BINDING
					) as WebGLTransformFeedback | null);
			TransformFeedback.bindingsCache.set(context.gl, boundTf);
		}

		return boundTf;
	}

	/**
	 * Bind a transform feedback.
	 * @param context - The rendering context.
	 * @param tf - The transform feedback.
	 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/bindTransformFeedback | bindTransformFeedback}
	 * @internal
	 */
	public static bindGl(
		context: Context,
		tf: WebGLTransformFeedback | null
	): void {
		// Do nothing if the binding is already correct.
		if (TransformFeedback.getBound(context) === tf) {
			return;
		}

		// Bind the transform feedback.
		context.gl.bindTransformFeedback(TRANSFORM_FEEDBACK, tf);
		TransformFeedback.bindingsCache.set(context.gl, tf);
	}

	/**
	 * Unbind the transform feedback that is bound.
	 * @param context - The rendering context.
	 * @param tf - The transform feedback to unbind, or `undefined` to unbind any transform feedback.
	 * @internal
	 */
	public static unbindGl(context: Context, tf?: WebGLTransformFeedback): void {
		// Do nothing if the transform feedback is already unbound.
		if (tf && TransformFeedback.getBound(context) !== tf) {
			return;
		}

		// Unbind the transform feedback.
		TransformFeedback.bindGl(context, null);
	}

	/**
	 * Create a transform feedback.
	 * @param program - The program to create the transform feedback for.
	 * @param varyings - The output buffers to attach to the transform feedback.
	 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/createTransformFeedback | createTransformFeedback}
	 */
	public constructor(program: Program, varyings?: VaryingMap) {
		super(program.context);
		this.program = program;

		this.internal = this.gl.createTransformFeedback();

		this.varyingsCache = new Map();
		if (!varyings) {
			return;
		}

		for (const [key, value] of Object.entries(varyings)) {
			if (!Object.hasOwn(varyings, key)) {
				continue;
			}

			this.setVarying(key, value);
		}
	}

	/** The shader program associated with this transform feedback. */
	public readonly program: Program;

	/**
	 * The API interface of this transform feedback.
	 * @internal
	 */
	public readonly internal: WebGLTransformFeedback;

	/**
	 * The values of varyings in this transform feedback.
	 * @internal
	 */
	private readonly varyingsCache: Map<string, VaryingValue>;

	/** The values of varyings in this transform feedback. */
	public get varyings(): ReadonlyMap<string, VaryingValue> {
		return this.varyingsCache;
	}

	/**
	 * Set the buffer that is bound to a varying in this transform feedback.
	 * @param name - The name of the varying.
	 * @param value - The buffer to bind to the varying.
	 */
	public setVarying(name: string, value: VaryingValue | VertexBuffer): void {
		const varying = this.program.varyings.get(name);
		if (!varying) {
			throw new BadValueError(`No varying named \`${name}\`.`);
		}

		this.bind();
		const realValue = "vbo" in value ? value : { vbo: value };
		varying.value = realValue;
		this.varyingsCache.set(name, realValue);
		this.unbind(); // The transform feedback must be unbound or else buffers that are bound to it can't be bound elsewhere.
	}

	/**
	 * Start getting transform feedback.
	 * @param primitive - The type of primitive to record.
	 */
	public begin(primitive: Primitive = Primitive.TRIANGLES): void {
		// The buffers that are being written to can't be bound elsewhere.
		for (const [, varying] of this.varyings) {
			varying.vbo.unbind();
		}

		this.program.bind();
		this.bind();
		this.gl.beginTransformFeedback(primitive);
	}

	/** Finish getting transform feedback. */
	public end(): void {
		this.gl.endTransformFeedback();
		this.unbind(); // The transform feedback must be unbound or else buffers that are bound to it can't be bound elsewhere.

		// Ensure that the correct data can be read from the buffers.
		for (const [, varying] of this.varyings) {
			varying.vbo.clearDataCache();
		}
	}

	/**
	 * Bind this transform feedback.
	 * @internal
	 */
	public bind(): void {
		TransformFeedback.bindGl(this.context, this.internal);
	}

	/**
	 * Unbind this transform feedback.
	 * @internal
	 */
	public unbind(): void {
		TransformFeedback.unbindGl(this.context, this.internal);
	}
}
